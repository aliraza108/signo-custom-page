<!-- Sign Builder Designer - Compact Iframe Version -->
<div class="sign-builder-container" style="margin: 1rem 0;">
  <iframe
    id="designer-iframe"
    src="https://customsigns.vercel.app/?product={{ product.id }}&variant={{ product.selected_or_first_available_variant.id }}"
    style="width: 100%; border: 1px solid #e5e7eb; border-radius: 8px; display: block;"
  ></iframe>
</div>

<style>
  .sign-builder-container {
    background: #f9fafb;
    border-radius: 8px;
  }
  
  #designer-iframe {
    min-height: 600px;
  }
  
  @media (max-width: 768px) {
    #designer-iframe {
      min-height: 500px;
    }
  }
</style>

<script>
  const CLOUDINARY_UPLOAD_URL = 'https://api.cloudinary.com/v1_1/dzeolercm/image/upload';
  const CLOUDINARY_UPLOAD_PRESET = 'sign_designs';
  const CLOUDINARY_FOLDER = 'sign-designs';
  const STOREFRONT_API_VERSION = '2025-01';
  const STOREFRONT_API_TOKEN = {{ settings.storefront_api_token | default: '' | json }};
  const STOREFRONT_API_URL = '/api/' + STOREFRONT_API_VERSION + '/graphql.json';
  const STOREFRONT_CART_ID_KEY = 'signo_storefront_cart_id';

  async function uploadDesignToCloudinary(dataUrl) {
    if (!dataUrl || typeof dataUrl !== 'string') return null;
    if (!dataUrl.startsWith('data:image/')) return null;
    const blob = await (await fetch(dataUrl)).blob();
    const fd = new FormData();
    fd.append('file', blob, 'design.png');
    fd.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
    fd.append('folder', CLOUDINARY_FOLDER);
    const res = await fetch(CLOUDINARY_UPLOAD_URL, { method: 'POST', body: fd });
    const json = await res.json();
    if (!res.ok || !json.secure_url) {
      throw new Error((json && json.error && json.error.message) || 'Design image upload failed');
    }
    return json.secure_url;
  }

  async function resolveDesignImageUrl(data) {
    if (typeof data.designImageUrl === 'string' && /^https?:\/\//i.test(data.designImageUrl)) return data.designImageUrl;
    if (typeof data.imageUrl === 'string' && /^https?:\/\//i.test(data.imageUrl)) return data.imageUrl;
    if (typeof data.customImage === 'string' && data.customImage.startsWith('data:image/')) {
      return await uploadDesignToCloudinary(data.customImage);
    }
    return null;
  }

  function toVariantGid(variantId) {
    const raw = String(variantId || '').trim();
    if (!raw) return '';
    if (raw.indexOf('gid://shopify/ProductVariant/') === 0) return raw;
    const idPart = raw.split('/').pop();
    return idPart ? ('gid://shopify/ProductVariant/' + idPart) : '';
  }

  function getStoredCartId() {
    try {
      return window.localStorage.getItem(STOREFRONT_CART_ID_KEY) || '';
    } catch (e) {
      return '';
    }
  }

  function setStoredCartId(cartId) {
    if (!cartId) return;
    try {
      window.localStorage.setItem(STOREFRONT_CART_ID_KEY, cartId);
    } catch (e) {}
  }

  function hasStorefrontToken() {
    return typeof STOREFRONT_API_TOKEN === 'string' && STOREFRONT_API_TOKEN.length > 0;
  }

  async function storefrontRequest(query, variables) {
    const res = await fetch(STOREFRONT_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Shopify-Storefront-Access-Token': STOREFRONT_API_TOKEN
      },
      body: JSON.stringify({ query, variables })
    });
    const json = await res.json();
    if (!res.ok || json.errors) {
      throw new Error((json && json.errors && json.errors[0] && json.errors[0].message) || 'Storefront API request failed');
    }
    return json.data || {};
  }

  function toLineAttributes(props) {
    return Object.keys(props || {}).map(function(key) {
      return { key: String(key), value: String(props[key]) };
    });
  }

  async function addToStorefrontCart(variantId, quantity, props) {
    const merchandiseId = toVariantGid(variantId);
    if (!merchandiseId) {
      throw new Error('Invalid variant ID for Storefront API');
    }

    const attributes = toLineAttributes(props);
    const cartId = getStoredCartId();

    if (cartId) {
      const addLineMutation = `
        mutation cartLinesAdd($cartId: ID!, $lines: [CartLineInput!]!) {
          cartLinesAdd(cartId: $cartId, lines: $lines) {
            cart {
              id
              checkoutUrl
            }
            userErrors {
              field
              message
            }
          }
        }
      `;
      const addData = await storefrontRequest(addLineMutation, {
        cartId: cartId,
        lines: [{ merchandiseId: merchandiseId, quantity: quantity, attributes: attributes }]
      });
      const addResult = addData.cartLinesAdd;
      if (addResult && addResult.userErrors && addResult.userErrors.length > 0) {
        throw new Error(addResult.userErrors[0].message || 'Unable to add line to existing cart');
      }
      if (addResult && addResult.cart && addResult.cart.id) {
        setStoredCartId(addResult.cart.id);
      }
      return addResult ? addResult.cart : null;
    }

    const createMutation = `
      mutation cartCreate($input: CartInput!) {
        cartCreate(input: $input) {
          cart {
            id
            checkoutUrl
          }
          userErrors {
            field
            message
          }
        }
      }
    `;
    const createData = await storefrontRequest(createMutation, {
      input: {
        lines: [{ merchandiseId: merchandiseId, quantity: quantity, attributes: attributes }]
      }
    });
    const createResult = createData.cartCreate;
    if (createResult && createResult.userErrors && createResult.userErrors.length > 0) {
      throw new Error(createResult.userErrors[0].message || 'Unable to create Storefront cart');
    }
    if (createResult && createResult.cart && createResult.cart.id) {
      setStoredCartId(createResult.cart.id);
    }
    return createResult ? createResult.cart : null;
  }

  // Pass product data to iframe with retries
  function sendProductDataToIframe() {
    const iframe = document.getElementById('designer-iframe');
    if (!iframe) {
      console.warn('Sign builder iframe not found');
      return;
    }
    
    // Prepare product data with all metafields
    const productData = {
      id: {{ product.id | json }},
      title: {{ product.title | json }},
      handle: {{ product.handle | json }},
      selected_or_first_available_variant: {
        id: {{ product.selected_or_first_available_variant.id | json }},
        price: {{ product.selected_or_first_available_variant.price | json }},
      },
      metafields: {{ product.metafields | json }},
      images: {{ product.images | map: 'src' | json }}
    };
    
    console.log('[Shopify] Sending product data to iframe:', productData);
    
    // Send product data to iframe
    try {
      iframe.contentWindow.postMessage({
        type: 'SHOPIFY_PRODUCT_DATA',
        product: productData
      }, '*');
      console.log('[Shopify] Product data sent successfully');
    } catch (e) {
      console.error('[Shopify] Error sending product data to iframe:', e);
    }
  }
  
  // Send data immediately when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', sendProductDataToIframe);
  } else {
    sendProductDataToIframe();
  }
  
  // Also send on window load and retry a few times
  window.addEventListener('load', () => {
    sendProductDataToIframe();
    // Retry after a short delay
    setTimeout(() => {
      sendProductDataToIframe();
    }, 100);
    setTimeout(() => {
      sendProductDataToIframe();
    }, 500);
  });
  
  // Dynamically resize iframe to fit content
  function resizeSignBuilderIframe() {
    const iframe = document.getElementById('designer-iframe');
    if (!iframe) return;
    
    try {
      const iframeContent = iframe.contentDocument || iframe.contentWindow?.document;
      if (iframeContent) {
        const height = iframeContent.documentElement.scrollHeight;
        iframe.style.height = (height + 20) + 'px';
      }
    } catch (e) {
      // Cross-origin, use message passing or keep default height
    }
  }
  
  // Resize on load and periodically
  document.addEventListener('DOMContentLoaded', resizeSignBuilderIframe);
  window.addEventListener('load', resizeSignBuilderIframe);
  
  // Listen for messages from iframe
  window.addEventListener('message', (event) => {
    if (!event.data) return;

    if (event.data.type === 'RESIZE_IFRAME') {
      const iframe = document.getElementById('designer-iframe');
      if (iframe) {
        iframe.style.height = (event.data.height + 20) + 'px';
      }
    }

    /* ========= RECEIVE ADD TO CART ========= */
    if (event.data.type === 'ADD_TO_CART') {
      (async function() {
        const iframe = document.getElementById('designer-iframe');
        try {
          const imageUrl = await resolveDesignImageUrl(event.data);
          if (!imageUrl) {
            throw new Error('No design image URL available');
          }

          const rawPrice = event.data.price != null ? event.data.price : event.data.unitPrice;
          const props = {};
          if (event.data.material) props['Material'] = event.data.material;
          if (event.data.size) props['Size'] = event.data.size;
          if (event.data.sides) props['Sides'] = event.data.sides;
          if (event.data.qty != null) props['Quantity'] = String(event.data.qty);
          if (rawPrice != null && rawPrice !== '') props['Price'] = '$' + Number(rawPrice).toFixed(2);
          props['Design Image'] = imageUrl;
          props['_Design Image URL'] = imageUrl;

          const cartData = {
            id: event.data.variantId,
            quantity: event.data.quantity || 1,
            properties: props
          };
          let storefrontCart = null;
          if (hasStorefrontToken()) {
            storefrontCart = await addToStorefrontCart(cartData.id, cartData.quantity, cartData.properties);
            console.log('[Shopify] Added to Storefront cart:', storefrontCart);
          } else {
            const response = await fetch("/cart/add.js", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(cartData)
            });
            if (!response.ok) throw new Error('Failed to add to cart');
            const result = await response.json();
            console.log('[Shopify] Added to AJAX cart:', result);
          }

          const cartResponse = await fetch('/cart.js');
          const cart = await cartResponse.json();

          document.documentElement.dispatchEvent(
            new CustomEvent('cart:refresh', { bubbles: true })
          );

          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage({
              type: 'CART_UPDATED',
              payload: { success: true, cart: cart, storefrontCart: storefrontCart, imageUrl: imageUrl }
            }, '*');
          }

          if (event.data.checkout) {
            if (storefrontCart && storefrontCart.checkoutUrl) {
              window.location.href = storefrontCart.checkoutUrl;
            } else {
              window.location.href = '/checkout';
            }
          }

        } catch (err) {
          console.error("[Shopify] Cart failed:", err);
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage({
              type: 'CART_ERROR',
              payload: { success: false, error: err.message }
            }, '*');
          }
        }
      })();
    }
  });
</script>
